import{_ as o,c as i,a as n,e as t,b as s,d as a,o as l,r}from"./404.md.f0d453c2.js";const I=JSON.parse(`{"title":"Convert Points Between Any Space (World, Entity, Bones)","description":"","frontmatter":{"title":"Convert Points Between Any Space (World, Entity, Bones)","category":"Tutorials","tags":["guide","info","intermediate"],"mentions":["Johnb003","SmokeyStack"]},"headers":[{"level":2,"title":"Overview","slug":"overview","link":"#overview","children":[]},{"level":2,"title":"Background","slug":"background","link":"#background","children":[{"level":3,"title":"Matrices","slug":"matrices","link":"#matrices","children":[]}]},{"level":2,"title":"Get to know the world before we start","slug":"get-to-know-the-world-before-we-start","link":"#get-to-know-the-world-before-we-start","children":[]},{"level":2,"title":"Finally!! Let's get started with an Entity","slug":"finally-let-s-get-started-with-an-entity","link":"#finally-let-s-get-started-with-an-entity","children":[]}],"relativePath":"entities/entity-transforms.md"}`),p={name:"entities/entity-transforms.md"},c=t('<h1 id="entity-transforms" tabindex="-1">Entity Transforms <a class="header-anchor" href="#entity-transforms" aria-hidden="true">#</a></h1><h2 id="overview" tabindex="-1">Overview <a class="header-anchor" href="#overview" aria-hidden="true">#</a></h2><p>In this page we&#39;ll discuss how to convert between different coordinate frames in Minecraft. There are many reasons why you might want to do this:</p><ul><li>If you wanted to build 3D lines using a thin cuboid to visualize some 3d space, you&#39;d need to transform from world coordinates to the entity bones.</li><li>If you wanted to do accurate head-tracking and wanted to measure the angle to a target from a specific joint on your entity.</li><li>If you wanted to fire off a projectile from the tip of a weapon.</li><li>If you wanted to solve IK Chains for limbs to match ground contact points.</li></ul><h2 id="background" tabindex="-1">Background <a class="header-anchor" href="#background" aria-hidden="true">#</a></h2><p>Before we jump into guide, there&#39;s a few background topics worth covering.</p><h3 id="matrices" tabindex="-1">Matrices <a class="header-anchor" href="#matrices" aria-hidden="true">#</a></h3><p>Generally by the time we send everything to graphics cards we convert things into matrices because it&#39;s really efficient to transform many vertices (such as for of a mesh) by a set of matrices. Games often work with other representations, such as quaternions, or in the case of Minecraft Euler rotations, but matrices are good to have a solid understanding of to start with.</p><p>If you see a 4x4 matrix full of a bunch of values, if you&#39;re not used to working with them, it might seem like you need to have special abilities to see through them, like this.</p>',9),d=s("p",null,'But, usually the sort of matrices we deal with for 3d transforms are just simply a positional offset and a rotation represented by "Axis vectors" that describe the X, Y, and Z axis, each as a 3-component vector.',-1),h=s("p",null,"When written in a 3x3 matrix the orientation vectors are unit-length vectors (unless there's scale), where these vectors are just like any direction vectors you're used to seeing they have an x,y,z component that define the axis directions of that space.",-1),u=t(`<p>In a 3x3 matrix (especially in textbooks), they&#39;re arranged in 2d array along the columns, like this:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">[ XAxis.x  YAxis.x  ZAxis.x ]</span></span>
<span class="line"><span style="color:#A6ACCD;">[ XAxis.y  YAxis.y  ZAxis.y ]</span></span>
<span class="line"><span style="color:#A6ACCD;">[ XAxis.z  YAxis.z  ZAxis.z ]</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>In programs you&#39;re always going to store the data in memory as <code>&lt;XAxis.x, XAxis.y, XAxis.z, YAxis.x, YAxis.y, YAxis.z, ZAxis.x, ZAxis.y, ZAxis.z&gt;</code>, whether you&#39;re row-major or column-major (<a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order" target="_blank" rel="noreferrer">Wiki about row vs column major</a>), it just means if you&#39;re row major you put the XAxis along the row. And if you&#39;re math library follows the rules, then it influences <strong>the order that things are multiplied together</strong>:</p><p>With ALL matrix multiplication it&#39;s always, row x column.</p><p>So, with <strong>Row-major</strong> to do multiplication of vectors and matrices it&#39;s: row_vector * matrix = row_vector:</p>`,5),y=s("p",null,[a("With "),s("strong",null,"Column-major"),a(" to do the same multiplication as the row major, you need to reverse the order:")],-1),m=t(`<p>The above distinction is really important to understand, especially if you read some material online to be able to understand the order that data transformed by it will be affected.</p><p>So this means, if we have a location relative to our right hand, and we want to know where that is in the world, we first have to transform it by our right hand, then our right elbow, then right shoulder, spine, pelvis, root, entity, etc. all the way until it&#39;s in world space. Written in column major that would be:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Entity * RootBone * Pelvis * Spine0 .. SpineN * RShoulder * RightElbow * RightHand * point;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>If you get into more complex transforms, it is strongly advised to name your transforms to reflect the space they transform from and to. So for the above we would use something like:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">World_To_Entity * Entity_To_Root * Root_To_Pelvis * Pelvis_To_Spine0 .. Spine(N-1)_To_SpineN * SpineN_To_RShoulder * RShoulder_To_RElbow * RElbow_To_RHand * RHand_point;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>We&#39;ll be less confused about what &quot;space&quot; we&#39;re in. The above is described as &quot;local space&quot;. Each joint is relative to the parent joint. But if we multiply everything from <code>Root</code> to <code>RHand</code>, the resulting transform is still an <code>RHand</code> transform, it&#39;s just in &quot;Character or Entity space&quot;. To get it into world space we&#39;d have to multiply <code>World_To_Entity * Entity_To_RHand = World_To_RHand</code></p><p>Technically, this &quot;To&quot; naming is a little confusing because the Entity transform applied to a point really transforms <code>EntityToWorld</code>, but it&#39;s applied right to left, so <code>World_To_Entity</code> read right to left is <code>Entity To World</code>. I&#39;ve also seen: <code>WorldFromEntity * EntityFromRoot</code>. Regardless of &quot;From vs To&quot;, what&#39;s nice about using this relative rather than absolute naming is that you can also validate your math is right when you see it written:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">A_To_B = A_To_Something * Something_To_B</span></span>
<span class="line"><span style="color:#A6ACCD;">              ^^^^^^^^^^^^^^^^^^^^^</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>the area denoted: <code>^</code> should always match. And combining it removing the middle gives you the natural name of what it does.</p><p>Finally, moving on to Minecraft. At the time of this writing, Minecraft doesn&#39;t have Transforms you can multiply together, so they aren&#39;t inferring a colum or row major notation. You simply get a transform and it&#39;s up to you how to apply it. But, having chosen column-major above, we can write down how the operations work as a sequence, and as long as you apply them in order, you&#39;ll be ok.</p><p>Also, whether we&#39;re using a TRS (Transform Rotation Scale combined object), Quaternions, Matrices, or Euler angles, when rotations are involved ORDER DOES MATTER. Rotate A then Rotate B, is not the same as rotate B and then rotate by A.</p><h2 id="get-to-know-the-world-before-we-start" tabindex="-1">Get to know the world before we start <a class="header-anchor" href="#get-to-know-the-world-before-we-start" aria-hidden="true">#</a></h2><p>Let&#39;s think about those Axis vectors in the unrotated, standard case. We actually can determine which way positive X, Y and Z are, by moving around in the world. When you first spawn into a game for the first time, you&#39;re facing due North, as the game calls it. Which if you then walk forward you&#39;ll see this increases your Z value. And if you jump you see Y goes up. And that leaves X, which is not right! Well it&#39;s not wrong, it&#39;s left! As you continue facing North, if you strafe left, this increases your X value. This is a right-handed coordinate system (if you point your fingers towards an axis, and curl them towards the next consecutive axis, your thumb points to the 3rd. XY-&gt;Z, YZ-&gt;X, wrap for Z: ZX-&gt;Y).</p><h2 id="finally-let-s-get-started-with-an-entity" tabindex="-1">Finally!! Let&#39;s get started with an Entity <a class="header-anchor" href="#finally-let-s-get-started-with-an-entity" aria-hidden="true">#</a></h2><p>When creating an entity, I recommend start out in blockbench, and make the first entity you create a simple 3-cardinal axis frame, like so:</p>`,15),b=s("p",null,'There are several weird things to recognize at this point. Pay very close attention to the directions that Blockbench labels "North, East, South, and West".',-1),g=s("ol",null,[s("li",null,'The first thing to note is that this is rotated 180 degrees from the Minecraft world coordinate system. You should make your Entity face "North" Which is negative Z compared to the game world coordinates.'),s("li",null,"It get's way more strange. If you move boxes in the positive X direction the box coordinates show as positive x values, however if you create a bone, and go to the animation tab, and try adjusting the position of the bone, the move handles are still as expected, but now dragging the handle in the positive direction, actually gives you negative values on X. +X in Animation goes to the west, while +Y still goes up, and +Z still goes south. So in comparison to the Minecraft world, we must flip the Z, and start using a left-handed coordinate frame in the entity."),s("li",null,`There's a scale factor of 16x in entities. A "Block" or 1 unit in the world, is actually 16 units in entities.`)],-1),v=s("p",null,"Let's try to group our 3-axis thing under a bone. And then duplicate that group, so we have one we can keep at the entity, and one we can move to a world location.",-1),w=s("ol",null,[s("li",null,"Go to the Animate Tab.")],-1),f=s("ol",{start:"2"},[s("li",null,"Create a new Animation.")],-1),_=s("ol",{start:"3"},[s("li",null,"Add a position key for the mover.")],-1),C=s("ol",{start:"4"},[s("li",null,"Try moving on the X-axis and confirm things are weird.")],-1),A=s("ol",{start:"6"},[s("li",null,[a("Now let's set the position using a variable, we'll set in a "),s("code",null,"pre_animation"),a(" script.")])],-1),D=t(`<ol start="7"><li>You should be able to mix and match from the minimal robot sample, to get an idea of how to get your entity started. Also you&#39;ll save out your blockbench geo, anim. On the behavior side, you don&#39;t need much for now. Perhaps just:</li></ol><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">minecraft:physics</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">minecraft:collision_box</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{}</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>On the entity side, you just need the minimum to play your animation:</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">animations</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">myAnim</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">animation.tut_transform.move</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">,</span></span>
<span class="line"><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">scripts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">: </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">pre_animation</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">// TODO -- we will fill this in next.</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">],</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">animate</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">myAnim</span><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">]</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>And finally for the script we can do the following:</p><div class="language-json line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.x = 10;</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.y = q.position(1);</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.z = 10;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C3E88D;">v.target.x = v.target.x - q.position(0);</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.y = v.target.y - q.position(1);</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.z = v.target.z - q.position(2);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C3E88D;">t.cos_yaw = math.cos(q.body_y_rotation);</span></span>
<span class="line"><span style="color:#C3E88D;">t.sin_yaw = math.sin(q.body_y_rotation);</span></span>
<span class="line"><span style="color:#C3E88D;">t.x = v.target.x;</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.x=t.cos_yaw * t.x + t.sin_yaw * v.target.z;</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.z=-t.sin_yaw * t.x + t.cos_yaw * v.target.z;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C3E88D;">v.target.x = v.target.x * 16;</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.y = v.target.y * 16;</span></span>
<span class="line"><span style="color:#C3E88D;">v.target.z = -v.target.z * 16;</span></span>
<span class="line"><span style="color:#89DDFF;">&quot;</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>Let&#39;s break it down a bit:</p><p>pre_animation runs before the animation, and runs this script. The script is intended to be given a position, perhaps your addon will supply the input through parameters from your behavior via a script?</p><p>For now you can hard-code these to the world location 10,y,10, where y is just at the same height as the entity.</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v.target.x = 10;</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target.y = q.position(1);</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target.z = 10;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>So in general what we&#39;re doing is applying a &quot;TRS&quot; Transform, Rotation, and Scale to get from one space to another.</p><p>Technically, remember we would write the transform stack like this:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Translation * RotationZ * RotationY * RotationX * Scale * point;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>But, in our case instead of transforming from ent to world, we&#39;re going to transform from world to ent. When we have inversable non-commutative math operations like this, the way to apply this inverse is with a property like this:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">inverse(A*B) = inverse(B) * inverse(A)</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Which means, do the opposite of the operation, in reverse order. So we apply these operations, in this order to our vector.</p><ol><li>inverse(Translation)</li><li>inverse(RotationZ)</li><li>inverse(RotationY)</li><li>inverse(RotationX)</li><li>inverse(Scale)</li></ol><p>mathematically that looks like:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">Inverse(Scale) * Inverse(RotationX) * Inverse(RotationY) * Inverse(RotationZ) * Inverse(Translation) * point;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>Which is happening right to left.</p><h4 id="_1-inverse-translation" tabindex="-1">1: Inverse(Translation) <a class="header-anchor" href="#_1-inverse-translation" aria-hidden="true">#</a></h4><p>If normally (in forward direction) you&#39;re going from ent to world, you&#39;d take your Entity-relative position (like a joint position) and add the entity&#39;s. So in reverse, we subtract the entitie&#39;s location.</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v.target_x = v.target_x - q.position(0);</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target_y = v.target_y - q.position(1);</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target_z = v.target_z - q.position(2);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="_2-inverse-rotationz" tabindex="-1">2: Inverse(RotationZ) <a class="header-anchor" href="#_2-inverse-rotationz" aria-hidden="true">#</a></h4><p>currently entities appear to only be able to adjust from the controllers via pitch and yaw. So no &quot;Z&quot;. So we skip that step.</p><h4 id="_3-inverse-rotationy" tabindex="-1">3: Inverse(RotationY) <a class="header-anchor" href="#_3-inverse-rotationy" aria-hidden="true">#</a></h4><p>To query the entity&#39;s yaw, there&#39;s a query method: q.body_y_rotation. We&#39;ll use that but consider that a positive rotation should make the character turn to the left. Rotating a vector by an angle, is a pretty simple formula, using sin and cos, but getting the sign right is important. Just think if you have a vector that starts facing world +z, and then get&#39;s rotated to the left, what will the +X axis become initially positive or initially negative? In our case X left is actually world space still so X left is positive. Likewise, if we had a vector facing positive +X (to the left), and we then started rotating to the left, the Z axis would start becoming?... Yes negative. You only negate the sine term. One last note, t.x is a temporary to save the value of the target</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">t.cos_yaw = math.cos(q.body_y_rotation);</span></span>
<span class="line"><span style="color:#A6ACCD;">t.sin_yaw = math.sin(q.body_y_rotation);</span></span>
<span class="line"><span style="color:#A6ACCD;">t.x = v.target_x;</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target_x=t.cos_yaw * t.x + t.sin_yaw * v.target_z;</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target_z=-t.sin_yaw * t.x + t.cos_yaw * v.target_z;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Note, generally, I like to write this as:</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">new_first_axis = cos(angle) * first_axis - sin(angle) * second_axis;</span></span>
<span class="line"><span style="color:#A6ACCD;">new_second_axis = sin(angle) * first_axis + cos(angle) * second_axis;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Where first and second axis are the two perpendicular axes to the one being rotated, but in right-hand order. So: XY, YZ, or ZX.</p><p>In other words, here&#39;s another alternative, that will be more consistent with other Euler angles, XY, and YZ.</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">t.cos_yaw = math.cos(q.body_y_rotation);</span></span>
<span class="line"><span style="color:#A6ACCD;">t.sin_yaw = math.sin(q.body_y_rotation);</span></span>
<span class="line"><span style="color:#A6ACCD;">t.z = v.target.z;</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target.z=t.cos_yaw * t.z - t.sin_yaw * v.target.x;</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target.x=t.sin_yaw * t.z + t.cos_yaw * v.target.x;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h4 id="_4-inverse-rotationx" tabindex="-1">4: Inverse(RotationX) <a class="header-anchor" href="#_4-inverse-rotationx" aria-hidden="true">#</a></h4><p>It is legitimately possible I think for entities to pitch, but in practice I haven&#39;t seen it. So I just skipped it.</p><p>It is an exercise for the reader, though later there will be more info when it comes to bone transforms, so you can get some additional context from that section (when I get to it).</p><h4 id="_5-inverse-scale" tabindex="-1">5: Inverse(Scale) <a class="header-anchor" href="#_5-inverse-scale" aria-hidden="true">#</a></h4><p>The last step, is to apply the scale from world to entity. Entities need to be represented with smaller units, so the operation in this direction is multiply. If we were going from ent to world it would be divided by 16.</p><p>And there&#39;s a sneaky little last negation included here, as was pointed out technically X is flipped from what it SEEMS like it should be in Blockbench when animating, but that actually lines it up with the world coordinate frame, wheres the Z is still opposite. So we just have to flip the Z in the scale step.</p><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">v.target.x = v.target.x * 16;</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target.y = v.target.y * 16;</span></span>
<span class="line"><span style="color:#A6ACCD;">v.target.z = -v.target.z * 16;</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>`,40);function x(k,F,T,E,q,S){const e=r("WikiImage");return l(),i("div",null,[c,n(e,{src:"/assets/images/tutorials/entity-transforms/image-1.png"}),d,h,n(e,{src:"/assets/images/tutorials/entity-transforms/image.png"}),u,n(e,{src:"/assets/images/tutorials/entity-transforms/image-2.png"}),y,n(e,{src:"/assets/images/tutorials/entity-transforms/image-3.png"}),m,n(e,{src:"/assets/images/tutorials/entity-transforms/image-4.png"}),b,g,v,n(e,{src:"/assets/images/tutorials/entity-transforms/image-5.png"}),w,n(e,{src:"/assets/images/tutorials/entity-transforms/image-6.png"}),f,n(e,{src:"/assets/images/tutorials/entity-transforms/image-7.png"}),_,n(e,{src:"/assets/images/tutorials/entity-transforms/image-8.png"}),C,n(e,{src:"/assets/images/tutorials/entity-transforms/image-9.png"}),A,n(e,{src:"/assets/images/tutorials/entity-transforms/image-11.png"}),D])}const j=o(p,[["render",x]]);export{I as __pageData,j as default};
